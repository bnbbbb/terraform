## CHAPTER 6 모듈

> 테라폼으로 인프라와 서비스를 관리하면 시간이 지날수록 구성이 복잡해지고 관리하는 리소스가 늘어나게 된다.
> 테라폼의 구성파일과 디렉토리 구성에는 제약이 없기 때문에 단일 파일 구조상에서 지속적으로 업데이트할 수 있지만, 다음과 같은 문제가 발생

- 테라폼 구성에서 원하는 항목을 찾고 수정하는 것이 점점 어려워짐
- 리소스들 간의 연관 관계가 복잡할 수록 변경 작업의 영향도를 분석하기 위한 노력이 늘어남
- 개발/스테이징/프로덕션 환경으로 구분된 경우 비슷한 형태의 구성이 반복되어 업무 효율이 줄어듦
- 새로운 프로젝트를 구성하는 경우 기존 구성에서 취해야할 리소스 구성과 종속성 파악이 어려움

ROOT MODULE -> Terraform -> Provider -> INFRASTRUCTURE
ROOT MODULE -> Terraform -> Provider -> INFRASTRUCTURE

- **루트모듈** : 테라폼을 실행하고 프로비저닝하는 최상위 모듈
- **자식모듈** : 루트 모듈의 구성에서 호출되는 외부 구성 집합

`모듈은 테라폼 구성의 집합`
테라폼으로 관리하는 대상의 규모가 커지고 복잡해져 생긴 문제를 보완하고 관리 작업을 수월하게 하기 위한 방안으로 활용

- **관리성** : 모듈은 서로 연관있는 구성의 묶음. 원하는 구성 요소를 단위별로 쉽게 찾고 업데이트할 수 있다. 모듈은 다른 구성에서 쉽게 하나의 덩어리로 추가하거나 삭제할 수 있다. 또한 모듈이 업데이트되면 이 모듈을 사용하는 모든 구성에서 일관된 변경 작업을 진행할 수 있다.
- **캡슐활** : 테라폼 구성 내에서 각 모듈은 논리적으로 묶여져 독립적으로 프로비저닝 및 관리되며, 그 결과는 은닉성을 갖춰 필요한 항목만을 외부에 노출 시킨다.
- **재사용성** : 구성을 처음부터 작성하려면 시간과 노력이 필요하고 작성 중간에 디버깅과 오류를 수정하는 반복 작업이 필요하다. 하지만 테라폼 구성을 모듈화하면 이후 비슷한 르보지너잉에 이미 검증된 구성을 바로 사용할 수 있다.
- **일관성과 표준화** : 테라폼 구성 시 모듈을 활용하는 워크플로는 구성의 일관성을 제공하고 서로 다른 환경과 프로젝트에도 이미 검증된 모듈을 적용해 복잡한 구성과 보안 사고를 방지할 수 있다.

### 6.1 모듈 작성 기본 원칙

> 모듈은 대부분의 프로그래밍 언어에서 쓰이는 라이브러리나 패키지 역할이 비슷하다.
> 모듈 작성 방식은 사용자마다 다를 수 있지만 기본 작성 원칙은 제공

- 모듈 디렉토리 형식은 terraform-<프로바이더 이름>-<모듈 이름> 형식을 제안함. 이 형식은 HCP Terraform, Terraform Enterprise에서도 사용되는 방식으로

  - 1. 디렉토리 또는 레지스트리 이름이 테라폼을 위한 것인지,
  - 2. 어떤 프로바이더의 리소스를 포함하고 있는지,
  - 3. 부여된 이름이 무엇인지 판별할 수 있도록 한다.

- 테라폼 구성은 궁극적으로 모듈화가 가능한 구조로 작성할 것을 제안.

  - 처음부터 모듈화를 가정하고 구성파일을 작성
  - 단일 루트 모듈이라도 후에 다른 모듈이 호출할 것을 예상하고 구조화할 수 있음
  - 작성자는 의도한 리소스 묶음을 구상한 대로 논리적인 구조로 그룹화할 수 있음

- 각각의 모듈은 독립적으로 관리하기를 제안

  - 리모트 모듈을 사용하지 않더라도 처음부터 모듈화가 진행된 구성들은 때로 루트 모듈의 하위 파일 시스템에 존재하는 경우가 있다.
  - 하위 모듈 또한 독립적인 모듈이므로 루트 모듈 하위에 두기보다는 동일한 파일 시스템 레벨에 위치하거나 별도 모듈만을 위한 공간에서 불러오는것을 권장
  - 이렇게 하면 VCS를 통해 관리하기가 쉬워짐

- 공개된 테라폼 레지스트리 의 모듈을 참고하기를 제안한다.

  - 대다수의 테라폼 모듈은 공개된 모듈이 존재하고 거의 모든 인수에 대한 변수처리, 반복문적용 리소스, 조건에 따른 리소스 활성/비활성 등을 모범 사례로 공개해 둠
  - 물론 그대로 가져오는 것보다는 프로비저닝 하려는 환경에 맞게 참고하는 것을 권장

- 작성된 모듈은 공개 또는 비공개로 게시해 팀 또는 커뮤니티와 공유를 제안
  - 모듈의 사용성을 높이고 피드백을 통해 더 발전된 모듈을 구성할 수 있는 자극이 됨

> 모듈화의 목적은 테라폼 코드를 작성하는 작업자마다 상이 점점 많아지고 복작해지는 구성 파일을 관리하기 위함이기도 하고 연관성 있는 리소스 집합을 묶어 모듈화하기도 함
> 모듈을 독립적으로 관리하기 위해 디렉토리 구조를 생성할 때 모듈을 위한 별도 공간을 생성하는 방식으로 진행한다.
> 특정 루트 모듈 하위에 자식 모듈을 구성하는 경우 단순히 복잡한 코드를 분리하는 용도로 명시되며 종속성이 발생하므로 루트 모듈 상위에 모듈 디렉터리를 지정한다.

**자식 모듈과 루트 모듈의 디렉토리 구조**

```
06-module-training
├──modules
   └── terraform-aws-my-module
       ├── main.tf
       ├── variables.tf
       ├── outputs.tf
       └── README.md
├── 06-01-basic
    └── main.tf
    └── variables.tf
    └── outputs.tf
    └── README.md
```

### 6.2 모듈화해보기

> 모듈은 기본적 구조는 테라폼 구성으로 입력 변수를 구성하고, 결과를 출력하기 위한 구조로 구성한다.
> `모듈화`라는 용어는 이런 구조를 재활용하기 위한 템플릿 작업을 말한다.
> 테라폼은 작서오딘 모듈을 다른 루트 모듈에서 가져다 사용하며 이를 통해 `재사용성`과 `표준화 구조`를 구성할 수 있다.

- 기존에 작성된 모듈은 다른 모듈에서 참조해 사용할 수 있음.
- 사용방식은 리소스와 비슷
- 모듈에서 필요한 값은 variable로 선언해 설정
- 모듈에서 생성된 값 중 외부 모듈에서 참조하고 싶은 값은 output으로 설정
- getter, setter로 캡슐화된 클래스를 활용하는 것과 비슷

> 하나의 프로비저닝에서 사용자와 패스워드를 여러 번 구성해야 하는 경우를 가상의 시나리오로 삼아 모듈화 진행

    - random_pet는 이름을 자동으로 생성하고, random_password는 사용자의 패스워드를 설정
    - random_password는 random 프로바이더 리소스로 난수 형태로 패스워드를 만들 수 있다.

#### 6.2.1 자식 모듈 작성 실습

> 모듈화를 진행하기 위해 앞서 말한 가상의 시나리오를 생각
> random 프로바이더 리소스 -> 하나의 프로비저닝에서 사용자와 패스워드를 여러 번 구성해야 하는 경우 random 프로바이더를 활용해볼 수 있다.

```
06-module-training
├──modules # child module directory
   └── terraform-random-pwgen
       ├── main.tf
       ├── variables.tf
       ├── outputs.tf
└── 06-01-basic # root module directory
    └── main.tf
```

#### 6.2.2 자식 모듈 호출 실습

> 모듈로 묶어진 리소스는 module이라는 정의를 통해 단순하게 재활용하고 반복 사용할 수 있다. 모듈의 결과 참조 형식은 module.<모듈 이름>.<output 이름>으로 정의됨
> `terraform init` 이후에 `.terraform/modules/modules.json` 파일을 확인해보면 여러 개의 모듈 정의가 있고 테라폼 구성에서 선언한 값이 각각 정의되어 있음

```
{
  "Modules": [
    { "Key": "", "Source": "", "Dir": "." },
    {
      "Key": "mypw1",
      "Source": "../modules/terraform-random-pwgen",
      "Dir": "../modules/terraform-random-pwgen"
    },
    {
      "Key": "mypw2",
      "Source": "../modules/terraform-random-pwgen",
      "Dir": "../modules/terraform-random-pwgen"
    }
  ]
}
```

### 6.3 모듈 사용 방식

모듈 사용 시 프로바이더 정의, 반복문 처리를 알아보자.

#### 6.3.1 모듈과 프로바이더

> 모듈에서 사용되는 모든 리소스는 관련 프로바이더의 정의가 필요함.
> 여기서 사용자는 프로바이더 정의를 모듈안에 둘어야 할지 밖에 두어야 할지, 구성을 고민할 수 있음.

##### 6.3.1.1 유형1

> 모듈에서 사용하는 프로바이더 버전과 구성 상세를 자식 모듈에서 고정하는 방법
> 프로 바이더 버전과 구성에 민감하거나, 루트 모듈에서 프로바이더 정의 없이 자식 모듈이 독립적인 구조일 때 고려할 방법
> 하지만 동일한 프로바이더가 루트와 자식 양쪽에 또는 서로 다른 자식 모듈에 버전 조건 합의가 안되면, 오류가 발생하고 모듈에 반복문을 사용할 수 없다는 단점이 있어 잘 사용되지 않음

##### 6.3.1.2 유형2

> 자식 모듈은 루트 모듈의 프로바이더 구성에 종속되는 방식
> 디렉토리 구조로는 분리되어 있지만 테라폼 실행 단계에서 동일 계층으로 해석되므로 프로바이더 버전과 구성은 루트 모듈의 설정이 적용된다.
> 프로바이더를 모듈 내 리소스와 데이터 소스에 일괄 적용하고, 자식 모듈에 대한 반복문 사용에 자유로운 것이 장점.
> 자식 모듈에 특정 프로바이더 구성의 종속성은 반영할 수 없으므로 자식 모듈을 테스트한 프로바이더 조건에 대해 기록하고, 자식 모듈을 사용하는 루트 모듈에서 정의하는 프로바이더에 맞게 업데이트 해야함.

동일한 모듈에 사용되는 프로바이더 조건이 다른 경우 각 모듈별로 프로바이더를 맵핑하는 방안.

- 리소스와 데이터 소스에 provider 메타인수로 지정하는 방식과 비슷하나 모듈에는 다수의 프로바이더가 사용될 가능성이 있으므로 map 타입으로 구성하는 provides로 정의한다.

```
06-module-training
├──modules
   └── terraform-aws-ec2
       ├── main.tf
└── multi_provider_for_module
    └── main.tf
```

#### 6.3.2 모듈과 반복문

> 모듈을 사용하는 경우 모듈의 입력 변수를 반복문으로 처리할 수 있다.
> 모듈이라는 리소스 정의 묶음을 원하는 수량으로 프로비저닝할 수 있으므로 모듈 없이 구성하는 것과 대비해 종속성 관리와 유지 보수에 장점이 있다.
> count를 사용한 반복문 사용은 리소스에서의 사용 방식처럼 module 블록 내에 선언한다.

```
provider "aws" {
    region = "ap-northeast-2"
}

module "ec2-seoul" {
    count = 2
    source = "../modules/terraform-aws-ec2"
}

output "module_output" {
    value = module.ec2-seoul[*].private_ip
}

```

- 모듈 묶음에 일관된 구성과 구조로 프로비저닝이 되는 경우라면 count가 간편한 방식이지만 동일한 모듈 구성에 필요한 인수 값이 다르다면 for_each를 사용하는 것이 좋다.

```
locals {
    env = {
        dev = {
            type = "t2.micro"
            name = "dev_ec2"

        }
        prod = {
            type = "t2.micro"
            name = "prod_ec2"
        }
    }
}

module "ec2-seoul" {
    for_each = locals.env
    source = "../modules/terraform-aws-ec2"
    instance_type = each.value.type
    instance_name = each.value.name
}

output "module_output" {
    value = module.ec2-seoul[*].private_ip
}
```

### 6.4 모듈 소스 관리

> Module 블록에 정의된 소스 구성으로 모듈의 코드 위치를 정의한다.
> terraform init을 수행할 때 지정된 모듈을 다운로드해 사용한다.
> 모듈 소스의 유형들

- 로컬 디렉토리 경로
- 테라폼 레지스트리
- 깃허브
- 비트버킷
- 깃
- HTTP URLs
- S3
- GCS (Google Cloud Storage)

#### 6.4.1 로컬 디렉토리 경로

> 로컬 경로를 지정할 때는 테라폼 레지스트리와 구분하기 위해 하위 디렉토리는 ./로, 상위 디렉토리는 ../로 지정한다.
> 대상 모듈은 이미 같은 로컬 파일 시스템에 존재하므로 다운로드 없이 바로 사용한다. 앞서 언급한대로 재사용성이 고려된다면 상위 디렉토리에 별도 관리하는 것을 권장하고,
> 항상 루트 모듈과 함께 동작해야 하는 걍우 하위 디렉터리에 모듈을 정의

```
module "local_module" {
  source = "../modules/my_local_module"
}
```

#### 6.4.2 테라폼 레지스트리

> 테라폼 모듈 레지스트리는 테라폼의 프로토콜을 사용해 모듈을 사용하는 방식이다.
> 공개된 테라폼 모듈을 사용하거나 HCP Terraform, Terraform Enterprise에서 제공하는 모듈을 사용할 수 있다.
> 각 모듈을 선택하면 테라폼 구성 시 어떻게 정의해야 하는지에 대한 안내를 확인할 수 있음.
> `https://registry.terraform.io/browse/modules` 에서 확인 가능

- 공개된 테라폼 모듈을 source에 선언할 때는 `<네임스페이스>/<이름>/<프로바이더>` 형태로 설정

```
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  version = "3.14.2"
}

```

Terraform Enterprise처럼 비공개 모듈을 사용할 때는 source 선언 시 주소가 앞에 추가되는 `<호스트 이름>/<네임스페이스>/<이름>/<프로바이더>` 형태로 설정

```
module "ecs_instance" {
  source = "app.terraform.io/alibaba/ecs-instance/alicloud"
  version = ">= 2.9.0"
}
```

**테라폼 레지스트리의 모듈은 특정 버전을 명시할 수 있으므로 안정된 버전을 지정해 사용할 수 있다.**

#### 6.4.3 깃허브

> 깃허브는 테라폼 구성에 대한 CI를 위한 용도로도 사용할 수 있고, 여기에 저장된 구성을 테라폼 모듈의 소스로 선언할 수도 있다.

> 다음은 소스로 활욯라기 위해 6.3절에서 활용한 terraform-aws-ec2를 깃허브에 업로드 하는 과정 설명

1. 깃허브 로그인
2. New repository -> 새로운 깃허브 저장소 생성

- Owner: 원하는 소유자 선택
- Repository name: 원하는 이름 선택
- Public 선택
- Add .gitignore의 dropbox에서 terraform 선택

3. Create repository 버튼 클릭

> 깃허브에서 공개된 모듈을 사용할 때는 `github.com/<소유자 아이디>/<디텍토리>/<디렉토리>` 형태로 설정
> 모듈의 버전은 깃허브 저장소의 태그 또는 브랜치 이름을 사용할 수 있다.

```
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  version = "3.14.2"
}
```
