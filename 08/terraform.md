## CHAPTER 8 워크 플로

**Write** : 코드를 작성
**Plan** : 적용하기 위한 실행 계획을 통해 리뷰
**Apply** : 코드로 인프라를 프로비저닝

### 8.1 규모에 따른 워크플로

> 사용자 개인이 테라폼으로 프로비저닝하는 워크플로는 다수의 작업자 또는 작업자 그룹간의 R&R에 따라 변화한다. 인프라가 확장되면 더 많은 작업자와 팀이 인프라를 관리해야 하고 협업을 위해서는 각 개인과 팀 간 권한을 유지하면서 병렬로 작업할 수 있는 환경을 구성해야 함

> 테라폼을 활용할 때도 각 워크스페이스 별로 접근 권한을 관리하고 중앙에서 관리되는 실행 환경을 설계하여 조직의 복잡성을 해결하고 프로비저닝에 집중하는, 규모에 맞는 워크플로 설계가 필요함.

#### 8.1.1 개인 워크플로

> 개인 환경에서는 테라폼 구성을 개인 저장소에 저장하고 개인 환경에서 테라폼 구성을 테스트하고 적용할 수 있음.

Write -> Plan -> Apply -> Write -> Plan -> Apply ... **무한반복**

**Write**

- 프로비저닝하려는 목적에 따라 테라폼 코드를 작성
- 주의점 : 개인 작업이더라고 반복적인 사용성을 고려해야함
- 인수에 할당되는 값을 입력 변수화하고 반복적인 구조가 발생하는 경우 리소스 단위별로 반복문을 사용할지 다수의 리소스를 모듈화할지 결정

**Plan**

- 테라폼의 Plan만을 의미하는게 아님
- `terraform fmt` 명령을 통해 코드 형태를 포맷팅하고 변경되는 리소스를 리뷰
- 테라폼과 함께 동작하는 tfsec, terrascan 같은 보안 취약성 점검 툴 등을 활용하는것도 좋은 방안

**Apply**

- 리뷰를 마치고 실제 인프라를 프로비저닝한다.
- 실행 계획상으로는 정상이지만 실제 프로비저닝하는 단계에서 인수 값, 생성 순서, 종속성에 따라 오류가 발생할 수 있음.
- 성공적인 완료를 위해 Write -> Plan -> Apply 과정을 반복해 성공하는 경우 코드 관리를 위해 VCS에 코드를 병합

#### 8.1.2 팀 워크플로

> 팀 워크플로는 개인 워크플로와 동일하지만 팀 간 협업을 위해 코드를 공유하고 협업을 위한 권한 관리가 필요함

| Write                                                             | Plan   | Apply |
| ----------------------------------------------------------------- | ------ | ----- |
| Write -> Plan -> Apply -> Write -> Plan -> Apply ... **무한반복** | Review | Merge |

**Write**

- 팀 간 협업을 위해 코드를 공유하고 협업을 위한 권한 관리가 필요함
- 팀 간 코드를 공유하고 협업을 위한 권한 관리가 필요함
- 민감 정보가 포함된 코드는 공유하지 않고 개인 저장소에 저장
- 이 단계에서 개인 워크플로 Write -> Plan -> Apply 과정을 반복해 성공하는 경우 코드 관리를 위해 VCS에 코드를 병합
- 개인 작업과 별개로 병합되는 코드가 실제 운영 중인 인프라에 즉시 반영되면 실행 후 발생할 오류 예측이 어려워 부담이 됨
- 이를 보완하기 위해 프로비저닝 대상의 환경을 검증과 운영, 또는 그 이상의 환경으로 구성 가능하도록 구조화
- 사용 방식은 디렉토리 기반 격리와 깃 기반의 브랜치 격리
  -> 깃 브랜치 격리 인터넷 환경에서 찾아보면 많은 예제가 있음

**Plan**

- 둘 이상의 작업자는 프로비저닝 이전에 팀원 간 리뷰를 거쳐 변경된 내역을 확인하고 공통 저장소에 병합
- 리뷰 단계에서 추가, 삭제, 수정된 내역을 관련 작업자가 검증, 질의, 배움의 단계를 거쳐 복기함으로써 코드 상태를 개선해 유지하고 작업자 간에 의도를 공유
- 코드 자체 외에도 테라폼의 Plan 결과를 풀리퀘스트 단계와 같이 제공하면 영향을 받는 리소스와 서비스 중단에 대한 예측이 더 쉬워진다.

**Apply**

- 리뷰를 마치고 실제 인프라를 프로비저닝한다.
- 실행 계획상으로는 정상이지만 실제 프로비저닝하는 단계에서 인수 값, 생성 순서, 종속성에 따라 오류가 발생할 수 있음.
- 성공적인 완료를 위해 Write -> Plan -> Apply 과정을 반복해 성공하는 경우 코드 관리를 위해 VCS에 코드를 병합

#### 8.1.3 프로젝트 워크플로

> 나중에

### 8.2 격리 구조

> 테라폼 수준에서의 격리는 State를 분리하는데 목적

- 테라폼은 파일이나 하위 모듈로 구분하더라고 동작 기준은 실행하는 루트 모듈에서 코드를 통합하고 하나의 State로 관리함
- 애플리케이션 구조가 모놀로식에서 MSA로 변화하는 과정은 테라폼의 IaC 특성과도 결부됨

|      | Monolithic Architecture                                                                                          | Micro Service Architecture                                                                              |
| ---- | ---------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| 장점 | 코드 통합이 용이하고 개발 환경 구성이 단순<br>단일 소수 인원 개발 편리<br>통합된 시나리오 검증 쉬움<br>배포 간편 | 소규모 기능 단위로 배포와 테스트가 용이<br>단위별로 새로운 구성 적용이 수월<br>서비스가 독립적으로 실행 |
| 단점 | 규모가 커지면 코드 추가, 수정, 삭제가 어려움<br>신규 작업자가 전체를 리뷰<br>부분적인 오류가 전체 영향을 줌      | 다수의 배포를 위한 프로세스 구현 필요<br>단위별 연계를 위한 로직 필요<br>나누는 기준 마련 필요          |

#### 8.2.1 루트 모듈 격리 (파일/디텍토리)

> 단일 작업자가 테라폼으로 프로비저닝 하는 경우에 관리 편의성 및 배포 단순화를 위해 하나의 루트 디렉토리에 파일로 리소스들을 구분하거나, 디텍토리를 생성하고 하위에 구성 파일 묶을을 위치시켜 루트 모듈에서 하위 디렉토리를 모듈로 읽는 구조를 사용함

```
08-root-module-isolation
├── main.tf
├── variables.tf
├── outputs.tf
└── modules
    └── terraform-aws-my-module
        ├── main.tf
        ├── variables.tf
        ├── outputs.tf
```

- 작업자가 관리하는 영역 또는 프로비저닝 되는 리소스 묶음의 독립적인 실행을 위해, 단일 루트 모듈 내의 리소스를 다수의 루트 모듈로 분리하고 각 모듈의 State를 참조하도록 격리함.
- 관리적인 측면으로는 작업자들의 관리 영역을 분리 시키고 깃 기준의 리모드 저장소도 접근 권한을 관리할 수 있음.
- 협업과 관련해 작업자별로 특정 루트 모듈을 선정 후 구성 작업을 진행해 코드 충돌을 최소화 하는 환경을 구성하고 인수인계 과정에서 리뷰하는 영역을 최소화할 수 있음

#### 8.2.2 환경 격리 - 깃 브랜치

> 서비스의 테스트, 검증, 운영 배포를 위해 테라폼으로 관리되는 리소스가 환경별로 격리되어야 한다면 디렉터리 구조로 분리하는 방안을 고려할 수 있음.

> 디렉터리별로 각 환경을 나누는 것은 개인의 관리 편의성은 높지마느 환경의 아키텍처를 고정시키고 코드 수준의 승인 체계를 만들기 위해서는 최종 형상에 대해 환경별 브랜치 구성하기를 권장함.

> 디렉터리 구조만으로 환경에 따라 사용자를 격리할 수 없음 -> 깃 브랜치 기능을 활용하면 환경별로 구별된 작업과 협업이 가능

**main** : 운영 코드가 관리되며 이곳에서 직접적으로 구성 변경을 수행하지 않음

**QA** : 검증 대상 인프라를 구성하는 코드로, 메인 브랜치와 같이 직접적인 구성 변경을 수행하지 않음.

**DEV** : QA 전 단계로 메인 코드 구성과 기능 브랜치의 병합을 담당

**feature** : 새로운 리소스를 추가하고 구현하며 여러 개가 될 수 있음
