## CHAPTER 7 협업

> IaC 도구인 테라폼은 코드 형태로 작성되므로 공유가 쉽고 재현이 가능함.
> 모듈을 활용해 구성을 쉽게 재사용하고 협업을 용이하게 할 수 있다.
> 테라폼으로 프로비저닝되는 인프라의 규모가 커지고 종류가 다양해질수록 다수의 구성 코드 관리가 필요함
> 공공 작업자는 작성된 코드를 점검하고 서로의 코드를 학습할 수 있는 협업 환경을 구성하게 된다.

**유형1**

- 동일한 대상을 관리하는 여러 작업자는 동일한 프로비저닝을 위해 서로 코드를 공유해야함
- 작업자의 수가 늘어날 수록 코드 동기화는 어려워지고 각 작업자가 작성한 코드를 병합하기도 어려움
- 이런 문제를 해결하기 위해 테라폼 구성을 모듈화하고 공유할 수 있는 환경을 구성하는 것이 중요
- 형상관리도구

**유형2**

- 형상관리 도구를 통해 여러 작업자가 동일한 코드를 공유해 구성함.
- 변경이력 관리 및 이전 버전 롤백 가능
- 공유해야 하는 대상은 테라폼 구성파일과 State 파일
- State의 경우 테라폼 프로비저닝의 결과물로 마치 데이터 저장소와 같다.
- 코드와 달리 State에는 형상관리 도구에 저장해서는 안되는 민감한 정보가 포함될 수 있고, 작업자가 서로 다른 프로비저닝을 수행한 State결과를 공유하는 경우 테라폼 프로비저닝 결과 오류가 발생할 수 있음.
- 테라폼은 State 관리를 위한 백엔드 설정을 제공함.

**유형3**

- 형상관리를 위한 중앙 저장소와 State 백엔드가 구성되면 작업자는 개별적으로 프로비저닝을 테스트하고 완성된 코드를 공유함.
- State는 중앙 관리 되어, 작업자가 프로비저닝을 수행하면 원격 State의 상태를 확인하고 프로비저닝을 수행한다.
- 그 결과는 State 백엔드에 저장되고 관리됨.

### 7.1 형상관리 도구

> 형상관리 도구는 코드의 변경이력을 관리하고 이전 버전을 롤백할 수 있는 기능을 제공하는 도구

- **SVN**
- **깃(Git)**

#### 7.1.1 깃(Git)

> 깃은 분산 버전 관리 시스템으로 코드의 변경이력을 관리하고 이전 버전을 롤백할 수 있는 기능을 제공함.

- 깃은 코드의 변경이력을 관리하고 이전 버전을 롤백할 수 있는 기능을 제공함.
  > 로컬 저장소 : 작업자 로컬 환경에 저장되는 개인 전용 저장소
  > 리모트 저장소 : 코드 형상관리 이력과 코드가 원격지에서 관리되고 여러 사람이 공유하는 저장소

#### 7.1.2 리모트 저정소 - 깃허브

### 7.2 코드 관리

> 깃허브는 포크 기능을 제공해 기존 리모트 저장소를 본인 소유의 저장소로 복사할 수 있음.

#### 7.2.1 공유 제외 대상

- .terraform 디렉토리 : `terraform init` 명령을 수행할 때 생성되는 디렉토리로 테라폼 구성 정보를 저장하는 디렉토리
- _.tfstate_ 파일 : 프로비저닝 결과 데이터 소스 정보이며, 민감 데이터가 포함되거나 다른 사용자가 같은 State 파일을 사용하는 경우 인프라 불합치를 유발함.
- _.tfvars_ 파일 : 프로비저닝 시 적용할 변수 값을 보관하는 파일로 작업자마다 별도 변수를 사용
- 시크릿파일 : 인프라 구성에 필요한 시크릿 정보 파일
- terraformrc 파일 : 작업자의 CLI 설정 파일

### 7.3 State 백엔드

> 백엔드 구성으로 테라폼의 State를 저장하는 위치를 설정한다.
> `State`는 테라폼에서 프로비저닝 결과를 추적하고 이후 프로비저닝 수행 시 비교하는 과정에 사용되므로 테라폼 사용 빈도와 대상의 규모가 커질수록 엄격한 관리가 요구됨.

**백엔드 관리하는 목적**

- **관리** : 백엔드 구성이 없는 경우 `State`는 local 구성이 기본으로 현재 `State`인 `terraform.tfstate`와 이전 상태인 `terraform.tfstate.backup`만이 보관되므로 지속적인 State 백업을 위해서 local 이외의 저장소가 필요
- **공유** : 다수의 작업자가 동일한 State로 접근해 프로비저닝하기 위하 공유 스토리지 필요
- **격리** : 민감한 데이터가 `State`파일에 저장될 가능성을 고려하여, 각각의 환경에 따라 접근 권한 제어 필요

| 종류       | 설명                                                                                |
| ---------- | ----------------------------------------------------------------------------------- |
| remote     | HCP TF / TFE의 워크스페이스를 의미하며, 1.1.0 부터 remote 백엔드에서 cloud로 명시화 |
| local      | 기본 백엔드로 로컬 파일 시스템에 구성                                               |
| azurerm    | Azure Blob Storage                                                                  |
| consul     | 하시코프 Consul의 KV(Key-Value Store)를 사용                                        |
| cos        | Tencent Cloud Object Storage                                                        |
| gcs        | Google Cloud Storage                                                                |
| http       | GET, POST, DELETE를 지원하는 REST 클라이언트 대상                                   |
| kubernetes | Kubernetes Secret                                                                   |
| oss        | Alibaba Cloud Object Storage Service                                                |
| pg         | Postgre Database                                                                    |
| s3         | Amazon S3 버킷을 사용하고, 추가로 DynamoDB 설정 시 State 잠금 및 일관성 검사 지원   |

#### 7.3.1 HCP Terraform, Terraform Enterprise 백엔드

> 테라폼은 다양한 백엔드를 지원하지만 프로비저닝하는 대상과 함께 운영하기도 함.
> AWS 를 프로비저닝 하는 경우 S3, Google Cloud 의 경우 GCS가 적합할 수 있다.
> 하시코프에서는 프로비저닝 대상과 별개로 State를 관리할 수 있도록 SaaS 환경인 HCP Terraform을 제공하며 State 관리 기능은 무상으로 제공

> Organization이 준비되면 작업자는 CLI 환경에서 HCP Terraform을 사용하기 위한 자격증명이 필요함
> HCP Terraform에서는 자격증명을 위해 토큰을 제공
> CLI 환경 설정 파일에 토큰을 저장하는 방법은 작업자가 직접 파일을 생성하고 내용을 기입하는 것도 가능하지만
> 여기서는 terrafrom login [hostname] 명령을 통해 자격증명을 얻을 수 있음.

#### 7.3.2 백엔드 구성

> 7.2정레서 사용한 Tom 의 루트 모듈 (terraform-aws-collaboration-tom)과 jerry의 루트 모듈(terraform-aws-collaboration-jerry)을 사용해 백엔드 구성과 동작을 확인한다. 이 과정에서는 두 작업자가 동일한 AWS 인프라를 프로비저닝하기를 원하는 상황이라고 간주함.

#### 7.3.3 백엔드 활용

> 테라폼 백엔드의 일부에서는 State에 대한 잠금 기능을 제공
> HCP TF / TFE, AWS S3 + DynamoDB, Postgre Database, Consul 등이 해당됨
> 백엔드를 공유하는 작업자는 프로비저닝 수행 시 동일한 State를 사용하므로 Apply 작업 시에는 State를 다른 작업이 접근하지 못하도록 잠궈야 함.

**무결성 확보**
